# mvp

元の詳細な設計をベースに、**「誰が実装しても100%動作し、迷いようがない最小構成（MVP）」**を定義します。

この定義書は、**「拡張性は維持しつつ、不確定要素（外部API連携、複雑なアルゴリズム）をすべて排除する」**ことを目的とします。開発者はこの指示書から1ミリも逸脱してはいけません。

---

# 1. 確実に動くための「鉄の掟」 (Demo Constraints)

開発のブレを防ぐため、以下の制約を厳守してください。

1. **外部サービス依存の禁止**: Google Drive API、Google OAuth は**廃止**。すべてローカル完結させる。
2. **RAG（ベクトル検索）の凍結**: `pgvector` と Embedding 生成は実装しない。LLMは「渡されたテキストの添削」のみを行う。
3. **PDF座標解析の廃止**: ハイライト機能は実装しない。テキストのみを扱う。
4. **TeX/ZIP対応の延期**: アップロードは **PDF単体ファイル** のみに限定する。
5. **認証の簡略化**: ログイン画面は作るが、パスワード不要の「デモユーザーとしてログイン」ボタン1つにする。

---

# コンテナ構造 (MVP仕様)

将来の拡張に備え、コンテナ構成（docker-compose.ymlの構造）は維持しますが、役割を極限まで単純化します。

### 1. フロントエンドコンテナ (User Interface)

- **役割**: Next.js (App Router) によるUI提供。
- **通信**: WebSocketは**廃止**。`SWR` または `setInterval` (3秒間隔) によるポーリングでステータスを監視する。
- **表示**:
- 詳細進捗バーは廃止。「解析中」か「完了」の2値のみ表示。
- 通知トレイは廃止。ステータスは画面中央に表示。

### 2. バックエンドコンテナ (API Server)

- **役割**: FastAPI。
- **認証**: JWTを発行するが、ユーザーは `id=1, role=student` の固定ユーザー（シードデータ）のみとする。Google連携は削除。
- **監視**: ゾンビタスク監視機能は**実装しない**。
- **DB管理**: 起動時に Alembic で `users`, `papers`, `tasks` テーブルを作成する。

### 3. パースコンテナ (Parser)

- **役割**: PDFからテキストを抽出する。
- **ライブラリ**: `pypdf` または `pdfminer.six` を使用。
- **処理**:
- 入力: ファイルパス。
- 出力: **プレーンテキストのみ**。
- **禁止事項**: 座標抽出、Markdown変換、章立ての構造化、TeX解析。すべて「ベタ書きのテキスト」として扱う。

### 4. タスク管理コンテナ (Redis)

- **役割**: シンプルなFIFOキュー (`rpush` / `blpop`)。
- **データ**: タスクIDのみを格納。複雑なステータス管理はDB側に任せる。

### 5. タスク作業コンテナ (Worker)

- **役割**: シングルプロセスで順次実行。並列処理はしない。
- **処理フロー**:
1. Redisからタスク取得。
2. Parserコンテナ（API）を叩いてテキスト化。
3. LLMコンテナ（API）を叩いて添削。
4. DBに結果保存。
- **リトライ**: 実装しない。エラー時は即 `Error` ステータスにして終了。

### 6. LLMコンテナ (Ollama)

- **役割**: `gemma2:2b` (軽量モデル) または `llama3` をホスト。
- **機能**: 渡されたテキストに対して、**固定のプロンプト**で返答するのみ。
- *プロンプト例*: 「以下の論文の要約と、誤字脱字の指摘をJSON形式で出力してください。」

### 7. データベースコンテナ (PostgreSQL)

- **役割**: メタデータ保存。
- **拡張**: `pgvector` はインストールしない。標準のPostgreSQLイメージを使用。

### 8. ストレージコンテナ (Local Storage)

- **変更点**: Google Drive 連携コンテナを**廃止**し、**Nginx (または単純なボリュームマウント)** に置き換える。
- **役割**: ローカルの `docker volume` を管理し、ファイルを保存・提供するだけとする。キャッシュ削除ロジックも実装しない。

---

# ページ設計 (MVP仕様)

### 1. ログインページ

- **要素**: 「デモを開始する」ボタンのみ。
- **動作**: クリックするとバックエンドからJWTを取得し、Cookieに保存してダッシュボードへ遷移。

### 2. ダッシュボード

- **要素**: 「論文一覧」リストのみ。
- 項目: タイトル、アップロード日時、ステータス（Pending/Done）。
- クリック動作: ステータスが `Done` の場合のみ詳細画面へ遷移。
- **削除**: タブ切り替え、検索機能、プロジェクトカード表示。

### 3. アップロード・モーダル

- **要素**: ファイル選択ボタン（`accept=".pdf"`）、タイトル入力欄、送信ボタン。
- **削除**: メタデータ入力、著者設定、ドラッグ＆ドロップ、複数ファイル対応。

### 4. フィードバック詳細画面

- **レイアウト**:
- 左側: **実装しない**（PDFプレビューなし）。
- 右側: AIの回答（Markdown）を表示するのみ。
- **削除**: スコア、ハイライト、RAG比較、Diff機能。

### 5, 6. 管理画面・研究室ライブラリ

- **全削除**。MVPには含めない。

---

# データベース設計 (MVP厳選)

テーブル数を減らし、リレーションを単純化します。

### 1. users

- `id`: 1 (固定)
- `name`: "Demo User"

### 2. papers

- `id`: Serial
- `user_id`: 1 (固定)
- `title`: Text
- `created_at`: Timestamp

### 3. tasks (inference_tasks + versions を統合)

- `id`: Serial
- `paper_id`: Integer (FK)
- `file_path`: Text (ローカルボリューム内のパス)
- `parsed_text`: Text (抽出された生テキスト)
- `status`: Varchar ('pending', 'processing', 'completed', 'error')
- `result_json`: JSONB (AIの回答)

---

# フロー設計 (MVP直線ルート)

分岐を一切許容しないフローです。

1. **Upload**:
- Frontend: ファイルをPOST。
- Backend: `/storage` (Volume) に保存。`papers` と `tasks` にレコード作成 (`status=pending`)。Redisに `task_id` をPUSH。
1. **Poll**:
- Frontend: 3秒ごとに `GET /papers` を叩き、ステータス更新を待つ。
1. **Process**:
- Worker: RedisからPOP。`status=processing` に更新。
- Worker: ファイルを読み込み、`pypdf` でテキスト抽出。`tasks.parsed_text` に保存。
- Worker: Ollama に「以下のテキストを要約せよ: {text}」とリクエスト。
- Worker: 結果を `tasks.result_json` に保存。`status=completed` に更新。
1. **View**:
- Frontend: `completed` を検知。ユーザーがクリックすると `GET /tasks/{id}` で結果を表示。

---

# 開発者への申し送り事項 (絶対遵守)

- **ファイル名は一意にしない**: テストを簡単にするため、同名ファイルアップロード時の上書きやエラーを考慮せず、Backend側で `uuid` を付与して保存すること。
- **エラーハンドリング**: エラーが起きたら復旧させず、コンテナを終了（再起動）させる設定 (`restart: always`) にすること。コード内で複雑な例外処理を書かない。
- **Ollamaモデル**: 初回起動時にモデルのpull (`ollama pull gemma2:2b`) が走るため、起動に時間がかかることを `README` に明記すること。

この設計であれば、論理的な破綻、外部要因によるエラー、複雑な状態管理によるバグは発生しません。まずはこれを動かし、「PDFを投げたらAIが感想を返す」というコア体験のみを確立してください。